<?xml version='1.0' encoding="UTF-8"?>
<chapter id="revisionlog">
	<title>Logging data for revisions</title>
	
    <para>
        Envers provides an easy way to log additional data for each revision. You simply need
        to annotate one entity with <literal>[RevisionEntity]</literal> (attribute) or <literal>SetRevisionEntity</literal> (fluent), 
		and a new instance of this entity will be persisted when a new revision is created (that is, whenever an
        audited entity is modified). As revisions are global, you can have at most one revisions entity.
    </para>

    <para>
        Please note that the revision entity must be a mapped Hibernate entity.
    </para>

    <para>
        This entity must have at least two properties:
    </para>

    <orderedlist>
        <listitem>
            <para>
                An integer- or long-valued property, annotated with <literal>[RevisionNumber]</literal>. Most
                often, this will be an auto-generated primary key.
            </para>
        </listitem>
        <listitem>
            <para>
                A long- or date- valued property, annotated with <literal>[RevisionTimestamp]</literal>. Value of
                this property will be automatically set by Envers.
            </para>
        </listitem>
    </orderedlist>

    <para>
        You can either add these properties to your entity, or extend
        <literal>DefaultRevisionEntity</literal>, which already has those two properties.
    </para>

    <para>
        To fill the entity with additional data, you'll need to implement the
        <literal>IRevisionListener</literal> interface. Its newRevision method will
        be called when a new revision is created, before persisting the revision entity.
        The implementation should be stateless and thread-safe. The listener then has to be
        attached to the revisions entity by specifying it as a parameter to the
        <literal>[RevisionEntity]</literal> attribute.
    </para>

    <para>
        Alternatively, you can use the <literal>GetCurrentRevision</literal> method of the 
        <literal>AuditReader</literal> interface to obtain the current revision, and fill it with desired information.
        The method has a <literal>persist</literal> parameter specifying, if the revision entity should be persisted
        before returning. If set to <literal>true</literal>, the revision number will be available in the returned
        revision entity (as it is normally generated by the database), but the revision entity will be persisted
        regardless of wheter there are any audited entities changed. If set to <literal>false</literal>, the revision
        number will be <literal>null</literal>, but the revision entity will be persisted only if some audited entities
        have changed.
    </para>

    <para>
        A simplest example of a revisions entity, which with each revision associates the
        username of the user making the change is:
    </para>

    <programlisting>[Entity]
[RevisionEntity(typeof(ExampleListener))]
public class ExampleRevEntity : DefaultRevisionEntity 
{
	public virtual string UserName {get;set;}
}</programlisting>

    <para>
        Or, if you don't want to extend any class:
    </para>

    <programlisting>[Entity]
[RevisionEntity(typeof(ExampleListener))]
public class ExampleRevEntity 
{
    [RevisionNumber]
    private int id;

    [RevisionTimestamp]
    private long timestamp;

    private string username;

    // Getters, setters, equals, hashCode ...
}</programlisting>

    <para>
        Having an "empty" revision entity - that is, with no additional properties except the
        two mandatory ones - is also an easy way to change the names of the table and of the
        properties in the revisions table automatically generated by Envers.
    </para>

    <para>
        In case there is no entity annotated with <literal>[RevisionEntity]</literal>, a default
        table will be generated, with the name <literal>REVINFO</literal>.
    </para>	
</chapter>