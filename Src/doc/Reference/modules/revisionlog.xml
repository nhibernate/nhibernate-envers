<?xml version='1.0' encoding="UTF-8"?>
<chapter id="revisionlog">
	<title>Logging data for revisions</title>

	<para>
		Envers provides an easy way to log additional data for each revision. You simply need
		to annotate one entity with <literal>[RevisionEntity]</literal> (attribute) or <literal>SetRevisionEntity</literal> (fluent),
		and a new instance of this entity will be persisted when a new revision is created (that is, whenever an
		audited entity is modified). As revisions are global, you can have at most one revisions entity.
	</para>

	<para>
		Please note that the revision entity must be a mapped Hibernate entity.
	</para>

	<para>
		This entity must have at least two properties:
	</para>

	<orderedlist>
		<listitem>
			<para>
				An integer- or long-valued property, annotated with <literal>[RevisionNumber]</literal>. Most
				often, this will be an auto-generated primary key.
			</para>
		</listitem>
		<listitem>
			<para>
				A long- or date-valued property, annotated with <literal>[RevisionTimestamp]</literal>. Value of
				this property will be automatically set by Envers.
			</para>
		</listitem>
	</orderedlist>

	<para>
		You can either add these properties to your entity, or extend
		<literal>DefaultRevisionEntity</literal>, which already has those two properties.
	</para>

	<para>
		To fill the entity with additional data, you'll need to implement the
		<literal>IRevisionListener</literal> interface. Its newRevision method will
		be called when a new revision is created, before persisting the revision entity.
		The implementation should be stateless and thread-safe. The listener then has to be
		attached to the revisions entity by specifying it as a parameter to the
		<literal>[RevisionEntity]</literal> attribute.
	</para>

	<para>
		Alternatively, you can use the <literal>GetCurrentRevision</literal> method of the
		<literal>AuditReader</literal> interface to obtain the current revision, and fill it with desired information.
		The method has a <literal>persist</literal> parameter specifying, if the revision entity should be persisted
		before returning. If set to <literal>true</literal>, the revision number will be available in the returned
		revision entity (as it is normally generated by the database), but the revision entity will be persisted
		regardless of wheter there are any audited entities changed. If set to <literal>false</literal>, the revision
		number will be <literal>null</literal>, but the revision entity will be persisted only if some audited entities
		have changed.
	</para>

	<para>
		A simplest example of a revisions entity, which with each revision associates the
		username of the user making the change is:
	</para>

	<programlisting><![CDATA[[Entity]
[RevisionEntity(typeof(ExampleListener))]
public class ExampleRevEntity : DefaultRevisionEntity
{
	public virtual string UserName {get;set;}
}]]></programlisting>

	<para>
		Or, if you don't want to extend any class:
	</para>

	<programlisting><![CDATA[[Entity]
[RevisionEntity(typeof(ExampleListener))]
public class ExampleRevEntity
{
	[RevisionNumber]
	private int id;

	[RevisionTimestamp]
	private long timestamp;

	private string username;

	// Getters, setters, Equals, GetHashCode ...
}]]></programlisting>

	<para>
		Having an "empty" revision entity - that is, with no additional properties except the
		two mandatory ones - is also an easy way to change the names of the table and of the
		properties in the revisions table automatically generated by Envers.
	</para>

	<para>
		In case there is no entity annotated with <literal>[RevisionEntity]</literal>, a default
		table will be generated, with the name <literal>REVINFO</literal>.
	</para>

	<section id="envers-tracking-modified-entities-revchanges">
		<title>Tracking entity names modified during revisions</title>
		<para>
			By default entity types that have been changed in each revision are not being tracked. This implies the
			necessity to query all tables storing audited data in order to retrieve changes made during
			specified revision. Envers provides a simple mechanism that creates <literal>REVCHANGES</literal>
			table which stores entity names of modified persistent objects. Single record encapsulates the revision
			identifier (foreign key to <literal>REVINFO</literal> table) and a string value.
		</para>
		<para>
			Tracking of modified entity names can be enabled in three different ways:
		</para>
		<orderedlist>
			<listitem>
				Set <property>nhibernate.envers.track_entities_changed_in_revision</property> parameter to
				<literal>true</literal>. In this case
				<classname>NHibernate.Envers.DefaultTrackingModifiedEntitiesRevisionEntity</classname> will
				be implicitly used as the revision log entity.
			</listitem>
			<listitem>
				Create a custom revision entity that extends
				<classname>NHibernate.Envers.DefaultTrackingModifiedEntitiesRevisionEntity</classname> class.
				<programlisting><![CDATA[[RevisionEntity]
public class ExtendedRevisionEntity : DefaultTrackingModifiedEntitiesRevisionEntity 
{
	 ...
}]]></programlisting>
			</listitem>
			<listitem>
				Mark an appropriate field of a custom revision entity with
				<interfacename>NHibernate.Envers.ModifiedEntityNames</interfacename> annotation. The property is
				required to be of <literal><![CDATA[ISet<string>]]></literal> type.
				<programlisting><![CDATA[[RevisionEntity]
public class AnnotatedTrackingRevisionEntity 
{
	...
	
	[ModifiedEntityNames]
	private Set<String> modifiedEntityNames;
		 
	...
}]]></programlisting>
			</listitem>
		</orderedlist>
		<para>
			Users, that have chosen one of the approaches listed above, can retrieve all entities modified in a
			specified revision by utilizing API described in <xref linkend="envers-tracking-modified-entities-queries"/>.
		</para>
		<para>
			Users are also allowed to implement custom mechanism of tracking modified entity types. In this case, they
			shall pass their own implementation of
			<interfacename>IEntityTrackingRevisionListener</interfacename> interface as the value
			of <code>RevisionEntityAttribute</code> annotation.
			<interfacename>IEntityTrackingRevisionListener</interfacename> interface exposes one method that notifies
			whenever audited entity instance has been added, modified or removed within current revision boundaries.
		</para>

		<example>
			<title>Custom implementation of tracking entity classes modified during revisions</title>
			<programlisting><filename>CustomEntityTrackingRevisionListener.cs</filename>
<![CDATA[public class CustomEntityTrackingRevisionListener 
	: IEntityTrackingRevisionListener 
{
	public void EntityChanged(Type entityClass, string entityName, object entityId, 
		RevisionType revisionType, object revisionEntity) 
	{
		((CustomTrackingRevisionEntity)revisionEntity)
			.AddModifiedEntityName(entityClass.FullName);
	}
	
	public void newRevision(object revisionEntity) 
	{
	}
}]]></programlisting>
			<programlisting><filename>CustomTrackingRevisionEntity.cs</filename>
<![CDATA[[RevisionEntity(typeof(CustomEntityTrackingRevisionListener))
public class CustomTrackingRevisionEntity 
{
	private int customId;
	
	[RevisionTimestamp]
	private long customTimestamp;
	
	private ISet<ModifiedEntityTypeEntity> modifiedEntityTypes 
						= new HashSet<ModifiedEntityTypeEntity>();
		 
	public void addModifiedEntityType(string entityName) 
	{
		modifiedEntityTypes.add(new ModifiedEntityTypesEntity(this, entityName));
	}
	
	public void removeModifiedEntityType(string entityName) 
	{
		modifiedEntityTypes.remove(new ModifiedEntityTypeEntity(this, entityName));
	}
		 
	...
}]]></programlisting>
			<programlisting><filename>ModifiedEntityNameEntity.cs</filename>
<![CDATA[public class ModifiedEntityTypeEntity 
{
	private Integer id;
	
	private CustomTrackingRevisionEntity revision;
		 
	private string entityName;
		 
	...
}]]></programlisting>
			<programlisting><![CDATA[var revEntity = AuditReader()
	.FindRevision(typeof(CustomTrackingRevisionEntity), revisionNumber);
var modifiedEntityTypes = revEntity.ModifiedEntityNames]]></programlisting>
		</example>
	</section>

	<section id="envers-tracking-properties-changes">
		<title>Tracking entity changes at property level</title>
		<para>
			By default the only information stored by Envers are revisions of modified entities.
			This approach lets user create audit queries based on historical values of entity's properties.

			Sometimes it is useful to store additional metadata for each revision, when you are interested also in
			the type of changes, not only about the resulting values. The feature described in
			<xref linkend="envers-tracking-modified-entities-revchanges"/>
			makes it possible to tell which entities were modified in given revision.

			Feature described here takes it one step further. "Modification Flags" enable Envers to track which
			properties of audited entities were modified in a given revision.
		</para>
		<para>
			Tracking entity changes at property level can be enabled by:
		</para>
		<orderedlist>
			<listitem>
				setting
				<property>nhibernate.envers.global_with_modified_flag</property>
				configuration property to
				<literal>true</literal>.
				This global switch will cause adding modification flags for all audited
				properties in all audited entities.
			</listitem>
			<listitem>
				using <literal>[Audited(WithModifiedFlag=true)]</literal>
				on a property or on an entity.
			</listitem>
		</orderedlist>
		<para>
			The trade-off coming with this functionality is an increased size of
			audit tables and a very little, almost negligible, performance drop
			during audit writes. This is due to the fact that every tracked
			property has to have an accompanying boolean column in the
			schema that stores information about the property's modifications. Of
			course it is Envers' job to fill these columns accordingly - no additional work by the
			developer is required. Because of costs mentioned, it is recommended
			to enable the feature selectively, when needed with use of the
			granular configuration means described above.
		</para>
		<para>
			To see how "Modified Flags" can be utilized, check out the very
			simple query API that uses them: <xref linkend="envers-envers-tracking-properties-changes-queries"/>.
		</para>
	</section>
</chapter>