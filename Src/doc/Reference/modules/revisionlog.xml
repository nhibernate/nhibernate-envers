<?xml version='1.0' encoding="UTF-8"?>
<chapter id="revisionlog">
	<title>Logging data for revisions</title>

	<para>
		Envers provides an easy way to log additional data for each revision. You simply need
		to annotate one entity with <literal>[RevisionEntity]</literal> (attribute) or <literal>SetRevisionEntity</literal> (fluent),
		and a new instance of this entity will be persisted when a new revision is created (that is, whenever an
		audited entity is modified). As revisions are global, you can have at most one revisions entity.
	</para>

	<para>
		Please note that the revision entity must be a mapped Hibernate entity.
	</para>

	<para>
		This entity must have at least two properties:
	</para>

	<orderedlist>
		<listitem>
			<para>
				An integer- or long-valued property, annotated with <literal>[RevisionNumber]</literal>. Most
				often, this will be an auto-generated primary key.
			</para>
		</listitem>
		<listitem>
			<para>
				A long- or date-valued property, annotated with <literal>[RevisionTimestamp]</literal>. Value of
				this property will be automatically set by Envers.
			</para>
		</listitem>
	</orderedlist>

	<para>
		You can either add these properties to your entity, or extend
		<literal>DefaultRevisionEntity</literal>, which already has those two properties.
	</para>

	<para>
		To fill the entity with additional data, you'll need to implement the
		<literal>IRevisionListener</literal> interface. Its newRevision method will
		be called when a new revision is created, before persisting the revision entity.
		The implementation should be stateless and thread-safe. The listener then has to be
		attached to the revisions entity by specifying it as a parameter to the
		<literal>[RevisionEntity]</literal> attribute.
	</para>

	<para>
		Alternatively, you can use the <literal>GetCurrentRevision</literal> method of the
		<literal>AuditReader</literal> interface to obtain the current revision, and fill it with desired information.
		The method has a <literal>persist</literal> parameter specifying, if the revision entity should be persisted
		before returning. If set to <literal>true</literal>, the revision number will be available in the returned
		revision entity (as it is normally generated by the database), but the revision entity will be persisted
		regardless of wheter there are any audited entities changed. If set to <literal>false</literal>, the revision
		number will be <literal>null</literal>, but the revision entity will be persisted only if some audited entities
		have changed.
	</para>

	<para>
		A simplest example of a revisions entity, which with each revision associates the
		username of the user making the change is:
	</para>

	<programlisting>
		[Entity]
		[RevisionEntity(typeof(ExampleListener))]
		public class ExampleRevEntity : DefaultRevisionEntity
		{
		public virtual string UserName {get;set;}
		}
	</programlisting>

	<para>
		Or, if you don't want to extend any class:
	</para>

	<programlisting>
		[Entity]
		[RevisionEntity(typeof(ExampleListener))]
		public class ExampleRevEntity
		{
		[RevisionNumber]
		private int id;

		[RevisionTimestamp]
		private long timestamp;

		private string username;

		// Getters, setters, equals, hashCode ...
		}
	</programlisting>

	<para>
		Having an "empty" revision entity - that is, with no additional properties except the
		two mandatory ones - is also an easy way to change the names of the table and of the
		properties in the revisions table automatically generated by Envers.
	</para>

	<para>
		In case there is no entity annotated with <literal>[RevisionEntity]</literal>, a default
		table will be generated, with the name <literal>REVINFO</literal>.
	</para>

	<section id="envers-tracking-modified-entities-revchanges">
		<title>Tracking entity classes modified in revision</title>
		<para>
			By default entity types that have been changed in each revision are not being tracked. This implies the
			necessity to query all tables storing audited data in order to retrieve changes made during
			specified revision. Envers provides a simple mechanism that creates <literal>REVCHANGES</literal>
			table which stores fully qualified names of .Net classes modified in each revision.
			Single record encapsulates the revision identifier (foreign key to <literal>REVINFO</literal> table)
			and a string value. Note that this mechanism shall be used when entity name can be clearly identified
			by Java class type. Otherwise extend <interfacename>IEntityTrackingRevisionListener</interfacename>
			interface (described further).
		</para>
		<para>
			Tracking of modified entity types can be enabled in three different ways:
		</para>
		<orderedlist>
			<listitem>
				Set <property>nhibernate.envers.track_entities_changed_in_revision</property> parameter to
				<literal>true</literal>. In this case
				<classname>nhibernate.envers.DefaultTrackingModifiedTypesRevisionEntity</classname> will
				be implicitly used as the revision log entity.
			</listitem>
			<listitem>
				Create a custom revision entity that extends
				<classname>nhibernate.envers.DefaultTrackingModifiedTypesRevisionEntity</classname> class.
				<programlisting>
					<![CDATA[
	[RevisionEntity]
	public class ExtendedRevisionEntity : DefaultTrackingModifiedTypesRevisionEntity {
		 ...
	}]]>
				</programlisting>
			</listitem>
			<listitem>
				Mark an appropriate field of a custom revision entity with
				<interfacename>nhibernate.envers.ModifiedEntityTypes</interfacename> annotation. The property is
				required to be of <literal><![CDATA[Set<String>]]></literal> type.
				<programlisting>
					<![CDATA[
	[RevisionEntity]
	public class AnnotatedTrackingRevisionEntity {
		 ...
	
		 [ModifiedEntityTypes]
		 private Set<String> modifiedEntityNames;
		 
		 ...
	}]]>
				</programlisting>
			</listitem>
		</orderedlist>
		<para>
			Users, that have chosen one of the approaches listed above, can retrieve all entities modified in
			specified revision by utilizing API described in <xref linkend="envers-tracking-modified-entities-queries"/>.
		</para>
		<para>
			Users are also allowed to implement custom mechanism of tracking modified entity types. In this case, they
			shall pass their own implementation of
			<interfacename>IEntityTrackingRevisionListener</interfacename> interface as the value
			of <code>RevisionEntityAttribute</code> annotation.
			<interfacename>IEntityTrackingRevisionListener</interfacename> interface exposes one method that notifies
			whenever audited entity instance has been added, modified or removed within current revision boundaries.
		</para>

		<example>
			<title>Custom implementation of tracking entity classes modified during revisions</title>
			<programlisting>
				<filename>CustomEntityTrackingRevisionListener.cs</filename>
				<![CDATA[
	public class CustomEntityTrackingRevisionListener : IEntityTrackingRevisionListener 
	{
		 public void EntityChanged(Type entityClass, string entityName, object entityId, RevisionType revisionType,
											object revisionEntity) 
											{
			  ((CustomTrackingRevisionEntity)revisionEntity).AddModifiedEntityName(entityClass.FullName);
	 }
	
		 public void newRevision(object revisionEntity) {
		 }
	}]]>
			</programlisting>
			<programlisting>
				<filename>CustomTrackingRevisionEntity.cs</filename>
				<![CDATA[
	[RevisionEntity(typeof(CustomEntityTrackingRevisionListener))
	public class CustomTrackingRevisionEntity {
		 private int customId;
	
		 [RevisionTimestamp]
		 private long customTimestamp;
	
		 private ISet<ModifiedEntityTypeEntity> modifiedEntityTypes = new HashSet<ModifiedEntityTypeEntity>();
		 
		 public void addModifiedEntityType(string entityName) {
			  modifiedEntityTypes.add(new ModifiedEntityTypesEntity(this, entityName));
		 }
	
		 public void removeModifiedEntityType(string entityName) {
			  modifiedEntityTypes.remove(new ModifiedEntityTypeEntity(this, entityName));
		 }
		 
		 ...
	}
	]]>
			</programlisting>
			<programlisting>
				<filename>ModifiedEntityNameEntity.cs</filename>
				<![CDATA[
	public class ModifiedEntityTypeEntity {
		 private Integer id;
	
		 private CustomTrackingRevisionEntity revision;
		 
		 private string entityName;
		 
		 ...
	}
	]]>
			</programlisting>
			<programlisting>
				<![CDATA[var revEntity = AuditReader().FindRevision(typeof(CustomTrackingRevisionEntity), revisionNumber);
	var modifiedEntityTypes = revEntity.ModifiedEntityNames]]>
			</programlisting>
		</example>
	</section>
</chapter>